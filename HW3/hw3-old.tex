%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt]{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \usepackage[dvips]{graphics}  --> see below
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\usepackage{moreverb}
\usepackage{alltt}
\usepackage{epic}
% \usepackage{ecltree}
\usepackage{latexsym}
\usepackage{amsgen}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{amscd}
\usepackage{amssymb}
\usepackage{epsf}
\usepackage{enumerate}

%\usepackage{macro}

% this logic enables both ps and pdf builds
% use 'includegraphics', not 'psfig' or 'epsfig'
\newif\ifpdf
\ifx\pdfoutput\undefined
        \pdffalse   % not running PDFlatex
\else
        \pdfoutput=1   %running PDFlatex
        \pdftrue
\fi

\ifpdf
  \usepackage[pdftex]{graphicx}
  \pdfcompresslevel=9
\else
  \usepackage{graphicx}
\fi


\newcommand{\eat}[1]{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\oddsidemargin=0in                              % Left margin minus 1 inch.
%\evensidemargin=0in                             % Same for even-numbered pages.
% \def\baselinestretch{0.93}
%\textwidth=7in                                % Text width (8.5in - margins).
%\topmargin=0in                                  % Top margin minus 1 inch.
%\headheight=0in                                 % Height of page header.
%\headsep=0in                                    % Distance from header to body.
%\textheight=9.1in                                 % Body height (11in - margins).


%\newif\iffullversion
%\fullversionfalse
%\fullversiontrue
%\renewcommand{\textfraction}{0}
%\renewcommand{\topfraction}{1}
%\renewcommand{\bottomfraction}{1}


%==============================================================================
% Macros.
%==============================================================================

\newtheorem{theorem}{Theorem}[section]          % Theorem environment.
\newtheorem{lemma}[theorem]{Lemma}              % Lemma environment.
%\newtheorem{corollary}[theorem]{Corollary}      % Corollary environment.
%\newtheorem{definition}[theorem]{Definition}    % Definition environment.
%\newtheorem{property}[theorem]{Property}        % Definition environment.
%\newtheorem{proposition}[theorem]{Proposition}  % proposition environment.
%\newtheorem{fact}[theorem]{Fact}                % fact environment.
\newenvironment{example}                        % Example environment.
  {\refstepcounter{theorem}\trivlist\item       %   Acts just like a theorem
  [\hskip\labelsep\bf Example \thetheorem]}%    %   environment, except that
  {\endtrivlist}                                %   body is typeset in
                                                %   Roman.

\newenvironment{pquery}                        % Example environment.
  {\refstepcounter{theorem}\trivlist\item       %   Acts just like a theorem
  [\hskip\labelsep\bf\sf Policy Query \thetheorem]}%    %   environment, except that
  {\endtrivlist}                                %   body is typeset in
                                                %   Roman.



\newcounter{query}
%\newenvironment{proof}                          % Proof environment.
%  {\trivlist\item[\hskip\labelsep\bf Proof:]}%  %   Puts "Proof:" in front of
%  {\unskip\nobreak\hfill~$\Box$\endtrivlist}    %   and box symbol after text.%%
\newenvironment{term}                           % Term environment.
  {\displaymath\def\\{{\ifnum0=`}\fi\def\\####1%%   Produces a left-indented
  {\def\tmpa{####1}\def\tmpb{[}\ifx\tmpa\tmpb   %   multiline equation.
  \def\\########1]{\ifnum0=`{\fi}\hidewidth\cr  %   "&" characters at the
  \noalign{\ifdim########1<1ex\penalty100\fi    %   beginning of a line produce
  \vskip########1\vskip\jot}}\relax             %   additional indentation,
  \else\def\\{\ifnum0=`{\fi}\hidewidth\cr       %   in the middle of a line
  \noalign{\penalty100\vskip\jot}####1}\fi\\}\\}%   they mark alignment points.
  \tabskip=1em\halign\bgroup\tabskip.3em&\vbox  %   "\\" starts a new line; it
  {\hrule height0pt width.7em\hbox{$##$}}\cr}%  %   can be given an opt. arg
  {\hidewidth\cr\egroup\enddisplaymath}         %   specifying extra leading.
\newcommand{\Rule}[1]                           % Type inference rule (as in
  {{\let\and\quad\let\implies\over#1}}          %   \Rule {a \and b\implies c})
\newcommand{\new}[1]{{\em #1\/}}                % New term (emphasized).
\newcommand{\set}[1]{\{#1\}}                    % Set (as in \set{1,2,3}).
\newcommand{\setof}[2]{\{{#1}\mid{#2}\}}        % Set (as in \setof{x}{x>0}).
\newcommand{\edge}{\mathbin{\rightarrow}}       % Edge (as in a \edge b).
\newcommand{\union}{\cup}                       % Tree union.
\newcommand{\gen}{\leftarrow}                   % Shallow generator.
\newcommand{\deepgen}{\mathrel{\gen\!\!\!\gen}} % Deep generator.
\newcommand{\FinSet}{{{\cal P}_{\rm fin}}}      % Finite sets constructor
\newcommand{\wild}{{\_}}                        % Edge wildcard.
%\newcommand{\implies}{\Rightarrow}              % Logical implication.
\newcommand{\eqdef}{\stackrel{\rm def}{=}}      % Defining equality.
\newcommand{\PTIME}{{\sc ptime}}                % The PTIME complexity class.
\mathcode`\?="426E                              % "?" produces "\" in math.
\mathcode`\!="005E                              % "!" produces "^" in math.
\mathcode`\*="0203                              % "*" is a \mathord in math.
\newcommand{\makeop}[2]                         % Macro to make new math syms.
  {\ifx#2.\def\next##1{}\else\escapechar=-1     %   Defines 2nd and subsequent
  \def\next##1{\escapechar=92\def#2{#1}}        %   args to expand to 1st arg,
  \expandafter\next\expandafter{\string#2}      %   with occurrences of "#1"
  \let\next\makeop\fi\next{#1}}                 %   replaced by cmd name.
\makeop{{\mskip-5mu}\mathrel{\sf{\lowercase{#1}}}}% MOAQL phrase lead-ins.
   \Input \Output \Select \Where \Range \Create \Link \Collect  %
   \If  \Foreach \Let .                         %
\makeop{\mathrel{\sf{\lowercase{#1}}}}          % MOAQL phrase separators.
  \From \Case \Of \And \Then \Else \Giving \appr
  \DB \IN \Not \matches \Do \In \flatten .              %
\makeop{{\sl #1\/}}                             % MOAQL Types.
  \String \Int \Real \Symbol                    %
  \Tree \Label \Oid \Bool \Dom .                %
\makeop{\mathop{\sl\lowercase{#1}\/}\nolimits}  % MOAQL functions & predicates.
  \isstring \isempty \deepflatten               %
  \gext \ext \vext \nodes \edges \root          %
  \false \true                                  %
  \Set \nest \unnest \joinnest                  %
  \outernest .                                  %
\makeop{{\cal #1}}                              % Various calligraphic letters.
  \C \B \D \F \G \U \V \W \X \Y \Z \D \I \C \A \O \L \P.    %

\newcommand{\scream}[1]{{\bf ***~{#1}~***}}

\newcommand{\xmltag}[1]{\mbox{$\tt <\hspace{-1mm}#1\hspace{-1mm}>$}}


\newcommand{\bisim}{\approx}
\newcommand{\simul}{\preceq}
\newcommand{\expand}[1]{#1^\infty}
\newcommand{\mean}[1]{[\!\![#1]\!\!]}

\newcommand{\itb}[1]{\mbox{\it #1}}
\newcommand{\pfb}[1]{\mbox{\bf #1}}
\newcommand{\sfb}[1]{\mbox{\sf #1}}

\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
\renewcommand{\bottomfraction}{1}

\newcommand{\lbr}{\mbox{$[$}}
\newcommand{\rbr}{\mbox{$]$}}

\newcommand{\card}[1]{\mid #1 \mid}

% schema is both singular and plural
\def\AddSpace#1{\ifcat#1a\ \fi#1} % if next is a letter, add a space
\def\schema#1{graph schema\AddSpace#1}
\def\schemas#1{graph schema\AddSpace#1}
\def\Schema#1{Graph schema\AddSpace#1}
\def\Schemas#1{Graph schema\AddSpace#1}

% \centerline{\renewcommand{\epsfsize}[2]{0.5#1}
% \rotate[r]{\epsfbox{file.ps}}}

\newcommand{\Colon}{\mathbin{:}}

\newcommand{\ql}{{\sc StruQL}}
\newcommand{\aql}{\mbox{\sc StruQL$_0$}}
\newcommand{\FO}{\mbox{FO}}
\newcommand{\var}{\itb{var}}
\newcommand{\avar}{\itb{avar}}
\newcommand{\nvar}{\itb{nvar}}
\newcommand{\atoms}{\itb{atoms}}
\newcommand{\points}{\itb{points}}


\newcommand{\untree}[2]{\begin{bundle}{#1}\chunk{#2}\end{bundle}}
\newcommand{\bintree}[3]{\begin{bundle}{#1}\chunk{#2}\chunk{#3}\end{bundle}}

\newcommand{\Dollar}{\$}

\newcommand{\map}{$\alpha^{\cal I}$}
\newcommand{\extr}{$R^{\cal I}$}
\newcommand{\extc}{$C^{\cal I}$}
\newcommand{\calp}{${\cal P}$}
\newcommand{\alcnr}{${\cal A}{\cal L}{\cal C}{\cal N}{\cal R}$}
\newcommand{\alc}{${\cal A}{\cal L}{\cal C}$}
\newcommand{\calf}{${\cal F}$}
\newcommand{\calc}{${\cal C}$}
\newcommand{\caln}{${\cal N}$}
\newcommand{\cala}{${\cal A}$}
\newcommand{\calo}{${\cal O}$}
\newcommand{\calw}{${\cal W}$}
\newcommand{\call}{${\cal L}$}
\newcommand{\calr}{${\cal R}$}
\newcommand{\calv}{${\cal V}$}
\newcommand{\cals}{${\cal S}$}
\newcommand{\calt}{${\cal T}$}
\newcommand{\cale}{${\cal E}$}
\newcommand{\cali}{${\cal I}$}
\newcommand{\cald}{${\cal D}$}

\newcommand{\reminder}[1]{[[[ \marginpar{\mbox{$<==$}} #1 ]]]}
\newcommand{\silentreminder}[1]{}

\newcommand{\Sharp}{\#}




% definitions for formulas and clauses
%
% \def \up(#1){#1\!\!\uparrow}
% \def \down(#1){#1\!\!\downarrow}

\def \up(#1){[#1)}
\def \down(#1){(#1]}

\def \trim{\mbox{trim}}



\newcommand{\mysum}[2]{\stackrel{\displaystyle \sum{\:\:{#2}}}{\scriptstyle {#1}}}

\newcommand{\lift}[1]{\stackrel{\displaystyle {#1}}{\displaystyle \mbox{\rule[-2mm]{0mm}{4mm}}}}

\def \E{\mbox{Employee}}
\def \pp{\mathcal{P}}
\def \tup{\mbox{\it tup}}
\def \dom{\mbox{\bf dom}}
\def \crit{\mbox{\it crit}}
\def \leak{\mbox{\it leak}}
\def \inst{\mbox{\it inst}}
\def \tru{\text{true}}
\def \fal{\text{false}}

\def \sec(#1,#2){#1 \: | \: #2}
\def \secd(#1,#2,#3){#1 \: |_{#2} \: #3}
\def \secdp(#1,#2,#3,#4){#1 \: |_{#2,#3} \: #4}
\def \usec(#1,#2,#3){\set{\series(#1,#2)} \:|\: #3}

\def \R(#1){{\bf #1}}
\def \var(#1){{\bf #1}}
\def \tr{\triangleright}
%\def \Pr{\mbox{Pr}}
\def \Pr{\mathbf{P}}
\def \Ex{\mathbf{E}}


\newcommand{\myvec}[1]{\langle #1 \rangle}
%\def \vec(#1){\langle #1 \rangle}

\def \series(#1,#2){#1_1, \dots \; #1_{#2}}
\def \serieszero(#1,#2){#1_0, #1_1, \dots \; #1_{#2}}

\def \n{\mbox{\sc nodes}}
\def \e{\mbox{\sc edges}}
\def \val{\mbox{\sc value}}
\def \DataValueType{\mbox{\sc DataValue}}
\def \LocalKeyType{\mbox{\sc LocalKey}}
\def \PublicKeyType{\mbox{\sc PublicKey}}
\def \NamedKeyType{\mbox{\sc NamedKey}}
\def \KeyType{\mbox{\sc Key}}

\def \para(#1){{\vspace{1ex}\noindent\small\bf #1\hspace{1ex}}}
\def \myem(#1){{\vspace{1ex}\noindent\small\em #1\hspace{1ex}}}

\newcommand{\ex}{\text{\em exp}}
\newcommand{\co}{\text{\em coeff}}
\newcommand{\red}{\text{\em red}}
\newcommand{\Relevant}{\text{\em Relevant}}
\newcommand{\un}{\mapsto}
\newcommand{\uns}{~\mbox{$\mapsto^{\!*}$}~}
\newcommand{\unified}{fully reduced}
\newcommand{\x}{(\frac{1}{n})}

\newcommand{\logentry}[1]{\texttt{<{#1}>}}
\newcommand{\numberpoints}[1]{\mbox{\bf [#1]}}

\title{\bf CSE 544 Homework 3 \\
  Due date: Thursday, March 10, 2011}

\author{}

\date{}



%===================================================================
\begin{document}
%===================================================================

\maketitle



\section{Transactions}

\begin{enumerate}

\item Refer to the textbook pp. 574, exercise 17.2.  For each scheulde
  in questions 6, 8, 10, 11, 12, determine whether the schedule is (a)
  conflict serializable, (b) view-serializable, (c) recoverable, and
  (d) avoids cascading aborts.

\item Textbook pp. 598, exercises 18.4 and 18.5.

\end{enumerate}


\section{Query Plans}

In this problem we will enumerate join plans.  For counting purposes
we assume the join operator is not commutative, i.e. the plans $R
\Join S$ and $S \Join R$ are consider to be distinct.
\begin{enumerate}
\item Consider the query $R_1(A_0,A_1) \Join R_2(A_1,A_2) \Join \ldots
  \Join R_n(A_{n-1},A_n)$ (all joins are natural joins).  How many
  distinct left-deep join plans without cartesian products are there
  for this query ?
  % Answer: 2^{n-1} To see this, note that after the fist few joins,
  % we have joined $R_i \Join R_{i+1} \Join \ldots \Join R_j$ At
  % this point we have two choices: expand left with $R_{i-1}$ or
  % expand right with $R_{j+1}$.  Thus, a plan can be described by a
  % 0,1-sequence of length n-1, telling us at each step 2, 3,
  % \ldots, n whether to expand left or expand right.  The total
  % number is 2^{n-1}.  Conversely, each such sequence uniquely
  % determines the first relation $R_k$: namely $k$ is equal to the
  % number of LEFT steps, plus one.
\item Consider the query $S(A_1, A_2, \ldots, A_n) \Join R_1(A_1,B_1)
  \Join \ldots \Join R_n(A_n,B_n)$.  How many distinct bushy join
  plans without cartesian products are there for this query ?
  % Answer: 2^n * n!.  To see this consider the last join operator.  It
  % must be either Ri join P, or P join Ri, for some Ri: in other
  % words it cannot be P join P' where neither P, P' are atomic
  % relations, because then it would have a cartesian product.  Thus,
  % #plans(n) = 2*n*#plans(n-1), hence 2^n * n!
  \end{enumerate}


\section{Relational Calculus}


\begin{enumerate}
\item This is the famous drinkers-beers-bars problem, used by Ullman
  in his early textbook on databases.  Consider the following schema:

\begin{verbatim}
Likes(drinker, beer), Frequents(drinker, bar), Serves(bar, beer)
\end{verbatim}

  We will abbreviate the table names with $L, F, S$.  For example the
  following query finds all drinkers that like only
  \texttt{Bud-Light}:

  \begin{eqnarray*}
    q(d) & :- & (\exists b.L(d,b)) \wedge (\forall b.L(d,b) \Rightarrow b=\texttt{Bud-Light})
  \end{eqnarray*}

  Note that the first condition ensures that the query is domain
  independent.

  For each of the questions below, write a relational query and then
  an equivalent relational algebra plan; draw the plan as a tree.

  \begin{enumerate}
  \item Find all drinkers that frequent only bars that serve only beer
    they like.  (Optimists)
  \item Find all drinkers that frequent only bars that serve some beer
    they like.  (Realists)
  \item Find all drinkers that frequent some bar that serves only
    beers they like.  (Prudents)
  \item Find all drinkers that frequent only bars that serve none of
    the beers they like. (Flagellators)
  \end{enumerate}


\item Consider the vocabulary $L(x,y), A(x), B(x)$ that represents two
  bit strings of length $n$ as follows:
  \begin{itemize}
  \item $L(x,y)$ is a strict, total order over an active domain of
    size $n$, meaning that it satisfies the following constraints:
    anti-reflexive $\neg L(x,x)$, anti-symmetric $\neg (L(x,y) \wedge
    L(y,x))$ and transitife $L(x,y)\wedge L(y,z) \Rightarrow L(x,z)$.
  \item $A(x),B(y)$ denote two input strings in $\set{0,1}^n$.
  \end{itemize}
  For example, if $n=3$, $A = 101$ and $B=110$, then define $L =
  \set{(u,v), (u,w), (v,w)}$, $A = \set{u,w}$, $B = \set{v,w}$.
  \begin{enumerate}
  \item Write a relational query to compute $C = A + B$.  Your query
    $q(x)$ returns all position $x$ in $C$ that are 1.  You will
    ignore the overflow bit, since you don't have a symbol for its
    position: for example, if $A = 101$ and $B= 110$ then you should
    return $C= 011$ (in other words, $q(x)$ returns $\set{u,v}$).
  \item {\bf This question requires some research} Is it possible to
    write multiplication in the relational calculus ?  The query
    $q(x,y)$ needs two head variables, because the product of two
    strings of length $n$ is a string of length $n^2$.  You need to
    research your answer and argue whether multiplication is possible,
    or not possible in the relational calculus.
  \end{enumerate}
  \end{enumerate}

\section{Datalog}



\begin{enumerate}
\item Consider a ternary relation $T(x,y, z)$ representing a graph,
  where each node $x$ has either zero or two outgoing edges $(x,y),
  (x,z)$.  Note that $x$ is a key in $T(x,y,q)$.  Consider the
  following game with two players.  Players take turns in moving a
  pebble on the graph.  If the pebble is on a node $x$, then the
  player whose turn it is may move it to one of the two children, $y$
  or $z$.  The player who cannot move (because the current node has no
  children), loses.  Write a datalog program to compute for each node
  whether player 1 or player 2 has a winning strategy.  Assume $L(x)$
  is a predicate containing all leaf nodes, i.e. $L(x) \equiv \neg
  \exists y.\exists z.T(x,y,z)$.
% P1(x) = player 1 wins, P2(x) = player 2 wins
% P2(x) :- L(x)
% P1(x) :- T(x,y,z),P2(y)
% P1(x) :- T(x,y,z),P2(z)
% P2(x) :- T(x,y,z),P1(y),P1(z)
\item {\bf Challenging question} Now consider the same game on a graph
  given by a binary relation $E(x,y)$; that is, a node $x$ may have an
  arbitrary number of children; as before $L(x)$ denotes the set of
  leaves.  Write a datalog$^\neg$ program to compute for each node
  whether player 1 or player 2 has a winning strategy.
% Solution
% First, write it like this:
% Win(x) :- E(x,y), L(y)
% Win(x) :- E(x,y), forall z. (E(y,z) --> Win(z))
% 
% Do the delay trick:
% 
% Lose(y,t) :- E(y,z), not Win(z), Win(t)
% Win(x) :- Win(t), E(x,y), not Lose(y,t)
% 
% Note that Lose(y) decreases in time.  If Lose(y) ever becomes false,
% then E(x,y),not Lose(y) becomes true, and then Win(x) becomes true

\item We discussed two possible semantics for datalog$^\neg$ in class.
  In {\em stratified semantics} the rules of the datalog program are
  partitioned into strata such that the IDBs occurring in strata $k$
  may only occur negated in bodies of rules belonging to strata $>k$.
  In {\em inflationary semantics}, we compute the datalog program such
  that at iteration $i+1$ we extend the content of the IDBs from
  iteration $i$ with new facts (i.e. we never remove facts from IDBs).
  Suppose a datalog$^\neg$ program can be stratified.  Do the two
  semantics coincide ?  If not, then give a counterexample of a
  datalog$^\neg$ program and EDBs such that the two semantics return
  two different answers.
% They do not coincide.  Let R={1} and S={1} and consider the program
% below:
% T(x) :- R(x)
% U(x) :- S(x), not T(x)
% under stratified semantics, U = emptyset; under inflationary
% semantics U = {1}
\item (Exercise 13.14 in AHV) Perform a magic-set optimization for the
  following datalog query:
\begin{verbatim}
  sgv(x,y) :- flat(x,y)
  sgv(x,y) :- up(x,z1), sgv(z1,z2), flat(z2,z3), sgv(z3, z4),down(z4,y)
  query(y) :- sgv(a,y)
\end{verbatim}
\item {\bf This question requires some research} Fix a vocabulary
  $E(x,y)$ where each instance represents a graph.  We have shown in
  class that every datalog$^\neg$ query can be computed in PTIME in
  the size of the graph.  Is it the case that any graph property that
  can be computed in polynomial time, can also be expressed in
  datalog$^\neg$ ? If your answer is {\em false} then give a
  counterexample.  You do not need to provide proofs, i.e. you can
  either answer {\em true}, or you can answer {\em false} and give a
  counterexample without proving that it is a counterexample.
  \end{enumerate}


\section{Conjunctive Queries}

 

\begin{enumerate}

\item For each of the queries below, find a semijoin reducer.  If the
  query admits a full reducer then your answer should be a full
  reducer; otherwise your answer can be any reducer that is not full,
  and you need to indicate that the query does not admit a full
  reducer.
  \begin{align*}
    q_1(x) :- & R(x,y), S(y,z), T(y,u) \\
    \\
    q_2(x) :- & R(x,y), S(y,z), T(z,u), M(z,v) \\
    \\
    q_3(x) :- & R(x,y), S(y,z), T(z,u), M(u,y)
  \end{align*}


\item Indicate for each pair of queries $q, q'$ below, whether $q
  \subseteq q'$.  If the answer is yes, provide a proof; if the answer
  is no, give a database instance $I$ on which $q(I) \not\subseteq
  q'(I)$.

  \begin{enumerate}
  \item
    \begin{eqnarray*}
      q(x)  & :- & R(x,y), R(y,z), R(z,x) \\
      q'(x) & :- & R(x,y), R(y,z), R(z,u), R(u,v), R(v,z)
    \end{eqnarray*}

  \item
    \begin{eqnarray*}
      q(x,y) & :- & R(x,u,u), R(u,v,w), R(w,w,y) \\
      q'(x,y) & :- & R(x,u,v), R(v,v,v), R(v,w,y)
    \end{eqnarray*}

  \item
    \begin{eqnarray*}
      q() &  :- & R(u,u,x,y),R(x,y,v,w),v\not=w \\
      q'() & :- & R(u,u,x,y), x\not=y
    \end{eqnarray*}

  \item
    \begin{eqnarray*}
      q(x) & :- & R(x,y), R(y,z),R(z,v) \\
      q'(x) & :- & R(x,y), R(y,z), y\not=z
    \end{eqnarray*}

  \end{enumerate}

\item Consider the two conjunctive queries below, and notice that $q_1
  \subset q_2$.

  \begin{align*}
    q_1(x) = & R(x,y), R(y,z) \\
    q_2(x) = & R(x,y)
  \end{align*}

  \begin{enumerate}
  \item Find a conjunctive query $r(x)$ s.t. $q_1 \subset r \subset
    q_2$
      % r(x) = R(x,y), R(u,v),R(v,w)
  \item {\bf Challenging question} Extend your answer: find an
    infinite set of queries $r_1(x), r_2(x), \ldots$ such they are
    inequivalent $r_i \not\equiv r_j$ for $i \neq j$, and for every
    $i$, $q_i \subset r_i \subset q_2$.  If you answer this question
    then you do not need to answer the preceding question.
      % rk(x) = R(x,y1),R(x1,y1),R(x1,y2), ..., R(xk,yk),R(yk,z)
  \end{enumerate}

\end{enumerate}

\section{Provenance}

Consider a relational database schema $R(A),S(B,C)$.  All queries
mentioned below are assumed to be monotone queries.


\begin{enumerate}
\item One of the answers $a$ of a relational query $Q$ has the
  provenance polynomial $x_1 y_1^2 + 2 x_2 y_1y_2$, where $x_1, x_2$
  are annotations of two tuples in $R$ and $y_1,y_2$ are annotations
  of two tuples in $S$.

  \begin{enumerate}
  \item Assume that the input relations are sets.  If we evaluate the
    query under bag semantics, how many copies of $a$ will be in the
    query's answer ?
  \item Assume that the input relations are bags, where each tuple
    occurs exactly twice.  If we evaluate $Q$ under bag semantics, how
    many copies of $a$ are there in the query's answer ?
  \item What is the smallest number of tuples that need to be removed
    from the database instance in order to remove $a$ from the answer
    to $Q$ ?
  \item Suppose that the tuple annotated with $y_2$ was incorrect (it
    contains some incorrect value).  Is the answer $a$ correct, or did
    it become incorrect ?
  \end{enumerate}


\item Consider the following instance:

\begin{tabular}{l|l|l} \cline{2-2}
$R$   & $A$ & \\ \cline{2-2}
       & $a_1$ & $x_1$ \\
       & $a_2$ & $x_2$ \\ \cline{2-2}
\end{tabular}
\begin{tabular}{l|l|l|l} \cline{2-3}
$S$   & $A$ & $B$ &  \\ \cline{2-3}
      & $a_1$ & $b_1$ & $y_1$ \\
      & $a_1$ & $b_2$ & $y_2$  \\
      & $a_2$ & $b_2$ & $y_3$  \\ \cline{2-3}
\end{tabular}

For each polynomial below, write a Boolean conjunctive query having
that provenance polynomial.  Your queries should not have constants or
the inequality predicates $\neq, <, \leq$.

\begin{align*}
  P_1 = & x_1y_1 + x_1y_2 + x_2y_3 \\
  P_2 = & x_1y_1^2 + x_1 y_2^2 + x_1 y_2y_3  + x_2 y_2y_3 + x_2 y_3^2 \\
  P_3 = & x_1^2y_1^2 + x_1^2 y_2^2 + 2 x_1x_2y_2y_3 + x_2^2 y_3^2
\end{align*}

% q = R(x),S(x,y)
% q = R(x),S(x,y),S(z,y)
% q = R(x),S(x,y),R(z),S(z,y)


\item Now we consider arbitrary instances $R$, $S$, and we assume that
  the tuples in $R$ are annotated with variables $x_1, x_2, \ldots$
  and the tuples in $S$ are annotated with $y_1, y_2, \ldots$ In each
  case below give an example of a Boolean conjunctive query whose
  provenance polynomial $P$ has the property stated below.  Your
  conjunctive query may use the predicate $\neq$.

  \begin{enumerate}
  \item The polynomial $P$ factorizes as $P = P_1 \cdot P_2$ where
    $P_1$ is a linear polynomial in $x_1, x_2, \ldots$ and $P_2$ is a
    linear polynomial in $y_1, y_2, \ldots$
  \item All monomials in $P$ have the form $x_i y_j y_k$ where $j\neq
    k$.
  \item All monomials in $P$ have the form $x_i x_j y_k$ where $i \neq
    j$.
  \end{enumerate}

\end{enumerate}



%===================================================================
\end{document}
%===================================================================
